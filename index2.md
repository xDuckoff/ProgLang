---
title: Kek
---

### Лекции 15, 16

#### Перечисления

*C\#:*

``` {.c#}
enum Color {
    Red   = 0xFF0000,
    Green = 0x00FF00,
    Blue  = 0x0000FF
}
var c = Color.Red;
c++; // Now has value 0xFF0001.

enum Planet {
    Earth,
    Mars
}
var c = Planet.Earth;
c++; // Now has value Planet.Mars.
```

``` {.c#}
enum TrafficColor:byte {
    Red,
    Yellow,
    Green
}
var tc = TrafficColor.Red;
```

``` {.c#}
enum FileMode {
    Read      = 0x1,
    Write     = 0x2,
    ReadWrite = Read | Write
}
```

В С\# есть механизм атрибутов (в частности это используется для задания
опций компилятора, как pragma в С), можно задать, какие операции
доступны для перечислимых типов:

``` {.c#}
[Flags] 
enum FileMode {
    Read      = 0x1,
    Write     = 0x2,
    ReadWrite = Read | Write
}
```

*C++11:*

``` {.c++}
// enum class
auto c = Color::Red;
```

Допускаются неявные преобразования из целого типа в перечислимый.
Обратно -- необходимо явное приведение. pragma не стандартизовано,
зависит от компилятора.

#### Указатели и ссылки

В Pascal -- не отдельный тип данных (просто способ передачи параметров).
Ссылки как отдельный тип данных -- С++ и Algol-68. Algol-68 --
ортогональность языка, стерта разница между оператором и выражением,
каждый оператор может иметь значение (например, оператор цикла имеет
значение последнего выполненного оператора).

``` {.algol-68}
ref int
ref T
ref ref int
```

В С ref перешли в \*, чтобы не вводить отдельно новую концепцию (уже
есть понятие машинного адреса, адресная арифметика). По факту вместо
индексации массивов можно использовать адресную арифметику (так как
массив в С -- непрерывный участок памяти, для индексации достаточно
знать начало массива и размер типа данных). В С++ & появилась как
отдельный тип данных (так как не все можно выразить через понятие
адреса, он слишком тесно связан с адресной арифметикой), например,
невозможно обойтись без этого типа при перегрузке операторов.

``` {.c++}
class MyVector {
    int *_body;
    int _size;
public:
    explicit MyVector(int size) {...}
    MyVector(MyVector & v) {...} // во избежание рекурсивного вызова конструкторов значение передается по ссылке
    // необходимо перегрузить операцию присваивания, потому что если оставить дефолтную, то будут утечки памяти
    // проблема висячих ссылок, когда сслка считается определенной, но она уже недействительна
    int& operator[](int i) {return _body[i];}// lvalue and rvalue. без & -- только rvalue
    MyVector& operator=(const MyVector & v) {
        ...
        return *this;
    }
};

MyVector v(30), v1(20);
v = v1; // проблема образования мусора (менеджер динамической памяти считает ее занятой, но на нее никто не ссылается), поэтому надо переобпределить операцию присваивания
MyVector v2(v); // v2 = v
v[j] = v1[i]; // нужно переопределить операцию []
```

> CLR: есть указатели, а есть gc\^ (garbage collect)

*Oberon:*

``` {.oberon}
RECORD D
    I:INTEGER   // закрытое поле
    J*:INTEGER  // открыто на чтение и запись
    J*-:INTEGER // открыто на чтение
```

T & a -- в С++ для ссылки доступна только операция иницаилизации (полный
аналог имени).

``` {.c++}
T & a = * new T(); // a -- имя безымянной переменной T()
X & b(*new X());
T & c = a; // "Остапа занесло", у объекта два имени, создает путаницу, так писать не надо
// как удалить? нужно получить адрес:
delete &a; // разыменование, и это работает, так у Страуструпа!
f(int & i) {} // инициализация i происходит в момент вызова
f(k);
```

``` {.c++}
class Y {
    int &ri; // где инициализировать? в конструкторе:
public:
    Y(int rri) : ri(rri) {...} // "порядочные компиляторы будут тут ругаться", переменная передается по значению (локальная переменная), инициализируем переменную значением стека!
};

int* f() {
    int i;
    return & i; // висячая ссылка, будет ошибкой
}

int& f1()n {
    int i;
    return i; // висячая ссылка, будет ошибкой
}

int f2(int &k); // обязательное предварительное объявление функций (так как возник второй способ передачи параметров, по ссылке)
```

**В объектно-референциалных ЯП:**

Типы данных: \* типы-значения (Value Types) \* референциальные
(обращение к ним возможно только через ссылку, именовать можно только
ссылки, объекты являются анонимными): \* классы \* интерфейсы \* массивы
(как правило. Исключение: Go (но он по факту не
объектно-референциальный))

``` {.java}
X x = new X();
int[] a = new int[30];
int[] b = new int[20];
a = b; // теперь а и b ссылаются на одну область
```

JavaScript: строки immutable, они не копируются, копируются только
ссылки.

Проблема поверхностного копирования: копирование только указателя или
ссылки. Как обеспечить глубокое копирование (вдруг есть ссылка на узел в
дереве, что тогда копировать? Только узел, поддерево, или вообще все
дерево? Нет универсального способа, где-то нужно делать полную копию, а
где-то частичную, это указывается автором структуры данных).

В С указатели играют роль и ссылок. С помощью адресной арифметики можно
обрабатывать произвольный набор данных (struct, union, T\[N\]).
Указатель в С по сути играет 2 роли, и, например, в объявлении функции
мы не всегда можем понять, для чего именно будет служить указатель (либо
как адрес -- strcpy(char *pa, char *pb), либо как передача значения --
swap(char *pa, char *pb)).

*Pascal:*

``` {.pascal}
P.field;
// := - присваивание, ^ - разыменование
P.all; // обращение ко всей переменной
```

``` {.ada}
T:INTEGER;
T'access;
PROCEDURE P is
    begin:
    ...
    end P;
P'access;
type PT is access all T;
```

Проблема владения: если структура объявлена внутри объекта, то объект
ответственен за освобождение структуры. Приобретение ресурса --
инициализация (RAII, resource acquisition is initialization). С++:
свертка стека -- при выходе из фрейма для всех локальных переменных
гарантируется вызов деструкторов в обратном порядке, кроме случая
аварийного завершения (при использовании исключений деструкторы будут
вызваны).

``` {.c++}
{
    // конструкция CWaitCursor w() означает прототип функции, поэтому надо (либо через new)
    CWaitCursor w; // захватывает курсор при инициализации, заменяет на waitcursor
    LongOp(); // как бы не закончилась эта операция, будет вызван деструктор для w
}
```

``` {.c++}
try {}
finally{} // здесь можно сделать освобождение памяти
```

*C\#:*

``` {.c#}
// IDisposable
using (X p = new X()) {
    s1...sn // операторы
}
try {
    X p = new X();
    s1...sn // операторы
}
finally { // гарантируется, что выполнится
    ((IDispose)p).Dispose; // освобождение неуправляемых ресурсов
}
```

*С++:*

``` {.c++}
p->field;
class SP {
    ...
public:
    ... 
    SP* operator->() {} // возвращает что-то, к чему применима -> (pointer)
};
```

\<вроде как до 11 года\>:

``` {.c++}
template<typename T>
class auto_ptr {
    ...
public:
    explicit auto_ptr(T *p = nullptr);
    auto_ptr(const auto_ptr<T> &);
    auto_ptr& operator=(auto_ptr<T> &);
    T* get();
    T* operator->();
    T& operator*();
    void swap(auto_ptr<T> &p);
    ~auto_ptr(); // delete
    // Можно прописывать свои deleter'ы
    ...
    // в конструкторе и деструкторе не должно быть исключений (потому что деструкторы могут быть вызваны во время свертки стека)
};

template<typename T>
void swap(auto_ptr<T> &p1, auto_ptr<T> &p2);
...
auto_ptr<X> px(new X());
pr->field;
auto_ptr<X> make() {
    auto_ptr<X> p(new X());
    ...
    return p; // будет работать конструктор копирования, который создаст новый auto_ptr (в нем нет const, по факту применяется операция swap)
}
```

``` {.c++}
void foo(auto_ptr<X> p) {
    ...
    // конструктор копирования, а затем деструктор (?!)
}

auto_ptr<X> p(new X());
foo(p);
p->bar(); // BOOOOM

// исправление:
void foo(const auto_ptr<X> & p) {}
```

``` {.c++}
struct s {
    int id;
    auto_ptr<X> p; // операция присваивания будет автоматической
    s();
}
s s1;
s s2;
s2 = s1;
s1.p->field; // НЕЛЬЗЯ, p уже ни на что не ссылается
```

Проблема auto\_ptr: вместо copy-семантики используется move-семантика.
Не пользуйтесь auto\_ptr!!! В 11 году: введение типа данных -- ссылки на
rvalue (временные объекты).

``` {.c++}
T && x = T();
```

``` {.c++}
T & x = T(); // временный объект будет уничтожен на выходе из блока
```

``` {.c++}
X a = getX();
X && b = getX(); // создается временный объект, которому будет присвоена ссылка на временный объект. конструктор копирования для временного объекта
X d(getX()); 
X c;
c = getX(); // здесь работает операция присваивания. После этого временный объект уничтожался. Компилятор: если объект поддерживает move-семантику, то надо ее использовать.

// в классе Х:
X(X&&);
X& operator=(X&&); 
```

Аналог в С++14:

``` {.c++}
std::unique_ptr<X> p;
```

Проблема в использовании копирования. В C++11 это сделано приватным
методом (копирование и присваивание с const X&). В С++14 введено
ключевое слово delete.

``` {.c++}
X(const X&) = delete;
```

``` {.c++}
std::unique_ptr<X> p, p1;
p = std::move(p1); // сколько байтов кода будет сгенерировано? нисколько, по факту просто приведение типов.
```

### Лекции 17, 18

### Виды памяти

-   Статическая
-   Квазистатическая (привязка статическая относительно стека во
    фрейме), проблем не возникает, так как все современные архитектуры
    поддерживают стек, есть соответствующие регистры (EBP, ESP)
-   Динамическая, тут возникают основные проблемы.
    -   Явное управление динамической памятью:
        -   C
        -   C++
        -   Rust
    -   Неявное управление:
        -   Java
        -   C\#
        -   JavaScript
        -   Python
        -   Swift
        -   Go

Понятие **владение**: владелец памяти ответственен за ее освобождение В
С++: концепция единоличного владения -- auto\_ptr (неудачная попытка)
Копирование противоречит концепции единоличного владения, с auto\_ptr
сложно отследить моменты копирования. unique\_ptr решает проблему, так
как отсутствуют оператор присваивания и конструктор копирования в
обычном понимании.

``` {.c++}
<Объявление метода> = delete; // этого метода по сути нет, он отменен (чтобы, например, не генерировался дефолтный конструктор копироавания)
X(X && rval) {}
operator=(X&& rval) {}
```

У unique\_ptr<T> есть операции \*, -\>, T\* get() \<=\> единоличное
владение shared\_ptr<T> -- \*, -\>, T\* get() \<=\> совместной владение.
Заводится счетчик ссылок. Методы этого класса могут отслеживать ссылки
друг на друга.

``` {.c++}
struct Item {
    std::shared_ptr<Item> pItem;
    string name;
    ...
};
int main() {
    auto Foo = make_shared<item>(); // внутри вызывается new, создается динамический блок, есть обычный указатель и много другой информации и методов
    std::shared_ptr<Item> Bar = make_shared<Item>(/*аргументы отсюда передаются в конструктор*/);
    // аналогично и с unique
    // Для них можно добавлять custom deleter
    Foo->pItem = Bar;
    // деструкторы: вызовется деструктор shared_ptr. Bar разрушится, потом разрушится Foo, и автоматически все будет освобождено.
}
```

custom deleter: например, для FILE\* -- deleter, который делает
fclose().

Главная проблема подсчета ссылок -- перекрестные ссылки
(cross-reference)

``` {.c++}
struct Item {
    std::shared_ptr<Item> pItem;
    string name;
    ...
};
int main() {
    auto Foo = make_shared<item>();
    std::shared_ptr<Item> Bar = make_shared<Item>();
    Foo->pItem = Bar;
    Bar->pItem = Foo;
    // ни один деструктор не вызовется, указатели разрушатся, а сам объект - нет, так как счетчик ссылок будет не нулевой. Поэтому было введено понятие слабых указателей
}
```

Слабые ссылки -- возникли в ЯП с динамической сборкой мусора. Слабая
ссылка -- ссылка на объект, который не был разрушен, но на него уже
никто не ссылается. Слабая ссылка может стать сильной (то есть станет
действительной).

``` {.c++}
std::weak_ptr<T> wptr; // не владеет объектом и не может его разрушать
// нет операций * и ->
// есть методы:
bool expired(); // можно сказать, валидна ли ссылка. в многопоточном окружении может быть небезопасным
std::shared_ptr<T> lock(); // переводит weak в разряд сильных ссылок
if (auto t = wptr.lock()) {
    // здесь безопасно работать с t
    t->...
    // при необходимости объект будет разрушен
} else {
    
}
```

``` {.c++}
struct Item {
    std::weak_ptr<Item> pItem;
    string name;
    ...
};
int main() {
    auto Foo = make_shared<item>();
    std::shared_ptr<Item> Bar = make_shared<Item>();
    Foo->pItem = Bar;
    Bar->pItem = Foo;
    // Ссылки становятся слабыми. Мы не владеем объектом, занчит, мы не можем к нему обращаться.Но решает проблему перекрестных ссылок. 
    // Также weak_ptr будет являться "наблюдателем" 
}
```

``` {.c++}
struct Item {
    std::unique_ptr<Item> pItem; // тут может быть сообщение об ошибке, так как для структур будет генерироваться конструктор копирования и оператор присваивания, нужно обеспечивать move-семантику
    // unique_ptr нельзя передавать по значению, так как нет конструктора копирования
    string name;
    ...
};
```

``` {.c++}
// (const) X * const - тип this
enable_shared_from_this(this) // тогда должно быть:
class X : public enabled_shared_from_this {...};
```

### Структурный базис

-   Массив
-   Запись (структуры в С/С++). В дальнейшем перешли в классы
-   Файлы. В дальнейшем ушли в стандартную библиотеку
-   Множества. В дальнейшем ушли в стандартную библиотеку или стали
    таблицами

``` {.pascal}
set of T; // отображение в числа от 0 до N-1
```

`Modula2 -? BITSET SET OF [0..N-1]` *Кортеж:* одновременное
присваивание. Неизменяем (в питоне) В С++ тоже появились кортежи:

``` {.c++}
std::tuple<int, char*> t;
std::get<i>(t);
```

*Массивы:* операция индексирования A: D x ... x D (n раз) \[ \]: A, i
-\> ref D // возваращается ссылка По факту динамическая операция Массивы
-- изменяемый объект. Строки в большинстве ЯП нельзя рассматривать как
массивы Нет выравнивания *Запись:* обращение к полю R: D1 x ... x Dn . :
R, name -\> ref Di Время связывания статическое Выравнивание -\> можно
делать масивы структур

Но в JavaScript все не совсем так. Массив -- напрерывная область памяти,
да, но записей в JS нет, есть объекты:

``` {.javascript}
var o = {}
o.prop = 1 // свойство с именем prop отыскивается во время выполнения
// если такого свойства нет, то оно добавится. Объект - как хэш-таблица свойств
// аналогично с индексированием:
o["prop"] = 1 // эта запись аналогична предыдущей, кроме того, что индекс может быть произвольным значением, приведенным к строке
// индексирование и обращение к полю - вычисление хэш-функции
var i = o.prop // если свойства prop нет, то значение i  будет "undefined"
delete o.prop // добавленное свойство можно удалить
```

#### Массивы

A: D x ... x D (n раз) \[ \]: A, i -\> ref D // возваращается ссылка В
общем случае применимы и другие операции: Length: A -\> n Если эта
операция выполняется в runtime, то массивы динамические, связывание
такой операции динамическое (C\#, Java, JS, list в Python). Проблема
настоящего динамического массива *C\#:*

``` {.c#}
T[] t = new T[N]; // N - длина массива
t.Length;// N
// IList<T> List<T> могут динамически менять длину, но могут быть не эффективны по памяти
```

*Python:*

``` {.python}
l = [1, 2, -28]
l.append("line")
# l[0] = 1
# l[4] = "line"
# l[5] - error
# l[-1] = "line", -1 is  len(l) - 1
```

*JavaScript:*

``` {.javascript}
var a = new Array()
a[i] = i // расширение массива, если элемента с таким индексом нет, то он появится
delete a[i] // удаление элемента
```

Есть ЯП, в которых длина массива -- статическая функция: *Pascal:*

``` {.pascal}
type ARR = array[1..N] of integer;
function SumARR(var A:ARR) : integer;
```

Modula, Oberon -- понятие открытого массива

    PROCEDURE SumARR( var A:ARRAY OF INTEGER):INTEGER; // неявно передается длина массива
    // HIGH(A) - значение последнего индекса в открытом массиве

*C:*

``` {.c}
pipe(int fd[2]);// передается именно массив, а не указатель
```

*Go:*

``` {.go}
var N int = 8
var arr [N]int // нельзя
var arr [8]int // можно
len(arr) // статически заменяется на 8
```

Вырезка (срез, slice) *Python:*

``` {.python}
# вырезка применима к общему объекту, который дает итератор и возможность индексирования
l[i:j:step] # default step = 1, default j = len(l), default i = 0
l[:] # весь массив
l = [1, 2, 3]
l1 = l
l[0] = 0
l1[0] # станет 0
l1 = l[:] # полная копия
l = [1, [1,2], 3]
l1 = l[:] # "копия глубокая, да не очень"
l1[1][1] = -1 # ссылка на второй элемент, он изменится
print(l) # выведется [1, [1,-1], 3]
l1 = l[::-1] # последовательность в обратном порядке, step=-1
```

*Swift:*

``` {.swift}
l[i..<j] // "окошко, через которое мы смотрим на массив"
let a = l[1:3]
// можно обращаться только к a[1], a[2], a[3]
```

*Go:*

``` {.go}
// окошко, через которое мы глядим на отдельный массив, как будто это отдельный массив
var arr = [4]int{1, 2, 3, 4}
// вырезка от элемента i до j - 1
// вырезка:
var s []int
s = arr[1:3] // все элементы, кроме первого и последнего
var arr1 = []int{1, 2, 3, 4, 5}
var s1 []int
s = arr1[1:4] // индексы 1, 2, 3
// функция make
a := make([]int, 5, 10) // 5 - len 10 - capacity, тип а - вырезки из int, массив будет длины 10, в вырезку войдут только 5 элементов
```

Detailed work of `make`:

``` {.go}
a := make([]int, 5, 6);
b := a[2:3]
fmt.Println(a, len(a), cap(a), len(b), cap(b)) // [0 0 0 0 0] 5 6 1 4
c := append(a, 1)
fmt.Println(a, len(a), cap(a), len(b), cap(b)) // [0 0 0 0 0] 5 6 1 4
fmt.Println(c, len(c), cap(c), len(c), cap(c)) // [0 0 0 0 0 1] 6 6 6 6
d := append(c, 2)
fmt.Println(d, len(d), cap(d)) // [0 0 0 0 0 1 2] 7 12
```

### Лекции 19, 20

-   Многомерные массивы
-   Записи и объединения
-   Кортежи
-   Таблицы (словари)

### Многомерные массивы

Есть типы-значения, а есть референциальные типы. \> Тип данных = Набор
значений + Набор операций

Язык без референциальных типов --

Семантика размещения объектов в памяти: \* Референциальные типы ---
значения в динамической памяти, доступны по ссылке \* Объекты
типов-значений --- не все так однозначно: в зависимости от контекста
объявления/появления соответствующего значения \* Ассемблер: данные
располагаются только внутри какого-то сегмента \* Другие языки:
возникает понятие области видимости --- \* Модуль. В С переменные,
объявленные в модуле, помещаются в глобальный сегмент данных, данные
загружаются в память, когда файл загружается в память (это происходит
еще до точки входа в программу). В модульных языках по-другому. С точки
зрения привязки к адресам --- статические переменные. В модульных яп
данные появляются в оперативной памяти: модуль загружается в память (но
загрузка может быть динамической, хотя все равно привязка будет
считаться статической) \* Блок. В С у таких переменных класс памяти ---
стек. \* Класс. Значеня типов-значений расположены внутри объектов этого
класса.

``` {.c#}
class X {
    T a = new T(); // ссылка
    T b;
    X(T bb) { b = bb; }
}
```

    int a[2][10]; // расположение в памяти по строкам (по столбцам только в Fortran)

*Непрямоугольный массив:* В яп типа С можно только моделировать.

``` {.c}
int main(int argc, char **argv) {}
int main(int argc, char *argv[]) {} // более наглядно, что argv - массив из указателей. здесь argv константный, в отличие от **argv, хотя они почти эквивалентны.
// **argv и *argv[] могут моделировать непрямоугольные массивы
```

Для типов-значений нужно знать длину массива, чтобы компилятор мог
разместить в памяти. Если не требуется сразу, то это референциальный
тип. Исключение --- динамические массивы в Ada.

``` {.java}
// Java
class Point{...}
Point[] p = new Point[N];
```

``` {.ada}
procedure P(N: integer) is
    var a: array(0..N-1) of integer;
    begin
    ...
    end P;
```

Динамические массивы из Ada перешли в C в виде VLA (C 99).

``` {.c}
int n = atoi(argv[1]);
int a[n];

void *alloca(size_t n); // выделяет память на стеке
```

*Java:*

``` {.java}
int[][] b = new int[N][];
for (int i = 0; i < N; i++) 
    b[i] = new int[i + 1];
// b[i][j]
int [,]a = new int[10, 5]; // Заметка от студента: НЕТ ТАКОГО СИНТАКСИСА В JAVA!
```

*C\#:*

``` {.c#}
struct Point {
    int x;
    int y;
    public Point(int x, int y) { this.x = x; this.y = y; }
    int X {
        get {return x;}
        set {x = value;}
    }
}

Point[] p = new Point[1]; // будет рассматриваться как массив объектов структур, семантика типа-значения (если бы Point был классом, то это был бы массив ссылок, и памяти затрачивалось бы больше)
// структуры нельзя наследовать. Есть класс struct, все структуры являются неявными наследниками этого класса
void foo() {
    Point p = new Point(1,2); // р будет расположен в стеке
}
class X{
    Point p = new Point(1,2); // p будет расположен внутри  объекта класса
}
void bar(object o) {} // в функцию можно передать все что угодно, если речь об ООП
bar(p);
```

### Записи и объединения

*Visual Basic: *

``` {.basic}
type S is
    name as string * 20
    surname as string * 40
end type
```

Записи (record) появились в языке COBOL, они использовались для записи
структур данных в файл. S. : точка позволяет получить ссылку на поле
(ref field) -- статическая операция, вычисление смщения относительно
адреса начала записи. Запись -- совокупность переменных.

``` {.java}
Math.sin(x)
...
// в Java нет статических классов
static import Math.*
```

``` {.c#}
static class Path{...} // в С# есть статические классы
```

``` {.c#}
double Integrate(double A, double B, double EPS, double (*()(double)))
```

``` {.java}
abstract class Integral {
    public double Integrate(double A, double B, double EPS) {..}
    public abstract double F(double);
}
new Integral {
    public double F(double x) {return sin(x);}
}().Integrate(0, PI, 1E-6); // new можно делать у анонимного абстрактного класса, у просто абстрактного нельзя
```

### Кортежи

В динамически типизированных яп понятия структур нет. В Python есть
понятие кортеж (размещаетяс в динамической памяти, имеет ссылочую
семантику, но менятьего нельзя)

``` {.python}
l = (1, 2, "string")
#l[0], l[1], l[2]
a, b, s = l #значения кортежа будут распакованы в эти переменные
f((a, b, s)) #запаковали a, b, s в новый кортеж
l = (a, b, s) #значения запакованы в кортеж
f(l)
```

### Словарь

*Python:*

``` {.python}
d = {"a":1, "b":2, "s":"string"}
d["a"] # обычный синтаксис обращения к словарю
# ключом может быть только неизменяемый объект (hashable, immutable)
# можно динамически вычислять имя записи
# словарь как частный случай записи
# коллизии - значение хэш-функции для разных ключей одинаково. Разрешение коллизий
```

В JavaScript словарь будет объектом:

``` {.javascript}
d = {"a":1, "b":2, "s":"string"} // стандартный способ работы с объектами, так задается любой объект, объект по определению является словарем
d.a // чтение: если не найдено свойство, то переходим к прототипу и так далее
d.с = d.s // запись: если свойства нет, то оно появится
```

*C++:*

``` {.c}
std::unordered_map<>; // 
```

*PHP:*

``` {.php}
$a[] = 1  
$a[1] // операция доступа к элементу массива, если он есть
$a["1"] // массив работает как хэш-таблица. Любой массив одновременно является хэш-таблицей с внутренним разрешением коллизий
```

### Кортежи (продолжение)

*Go:* осталось понятие структуры (кортежи тоже есть в каком-то виде).
Структуры по сути нужны были для того, чтобы функция могла вернуть
несколько значений, в Go можно так:

``` {.go}
val, _ = Fun(...)
//или
val, err = Fun(...)
```

*C++:*

``` {.c++}
std::tuple<int, int, std::string> p = mstd::make_tuple(1, 2, "string"/*const char* -> std::string*/);
std::get<0>(p); // p[0]
// C++14 - расширение стандарта для кортежей произвольных размеров (переменный список параметров в шаблоне)
```

### Объединение типов

\#\#\#Лекции 21, 22

### Объединение типов

(Pascal --- вариантные записи) Некоторый вариант структуры: \*
Размеченные (дискриминированные) \* Неразмеченные

Дискриминант: \* Code: Bar Code --- 4 int (NS, MC, PC, C), or QR Code
--- string \* Event: Event Type --- Mouse click, Keyboard event...

Если в размеченном объединении убрать дискриминант, оно станет
неразмеченным (так реализовано в С --- union, все элементы начинаются с
одного и того же адреса). Каждый из этих типов начинается со своего
short-поля (которое по факту можно считать дискриминантом объединения).

``` {.c}
struct sockaddr {
    short family; // указатель на реальный адрес приводить к этому типу
};
int bind(int sd,  struct sockaddr *pAddr);

/* Структура sockaddr_in описывает сокет для работы с протоколами IP. 
Значение поля sin_family всегда равно AF_INET. */
struct sockaddr_in {
    short sin_family;
    struct addr_in;
};
struct sockaddr_un {
    short sun_family; /* AF_UNIX */
    char path[108]; /* Pathname */
};
```

Описываем варианты дискриминанта с помощью конечного числа констант
(дискриминант --- перечислимый тип).

> Самое страшное, конечно, это сексуальное насилие, а то, что там
> свидания --- это ничего, ничего (о разделении общежитий гз на мужские
> и женские).

``` {.c}
// "две дыры" в контроле типов (в Паскале таких нет):
T *ptr = (T*)malloc(sizeof(*ptr));
free(ptr); // можно без приведения типов
```

В Паскале могут быть неразмеченные объединния (и это "дыра"). (См. еще
тип данных ADDRESS, Modula2). В Обероне объединения убрали.
"Диспетчеризация по полю типа" --- плохой стиль ООП (проблема в том, что
почти любое содержательное действие, кроме разве что присваивания, с
объектами таких иерархий должно происходить с помощью оператора выбора),
надо использовать интерфейс виртуальных функций. В отдельных случаях
приходится прибегать к диспетчеризации, например, если есть вложенный
цикл с только виртуальными функциями, это замедляет работу программы,
можно использовать объединение с полем типом, производительность
вырастет. Записи с вариантами из ЯП исчезли, так как считается, что
наследование типов перекрывает необходимость в дискриминантах (и вообще
это ненадежно). Например, в Ada при размещении записи в памяти,
необходимо было размещать там и дискриминант (это снижало ненадежность,
но не сильно). Мы могли использовать поля из другого типа объединения, и
это никак не исправлялось.

Концепция записи с вариантами связана с оператором выбора. И хорошо бы
привязывуать туда перечислимый тип данных.

#### Объединения в Swift

Записи появляются, если не нужно никакое наследование (нечего
наследовать). Это должно быть безопасно, нужны только размеченные
объединения с перечислимым типом данных. Оказалось, что концепция
перечислимого типа может покрыть эту необходимость.

``` {.swift}
enum Planets {
    case mercury=1, // case намекает на использование оператора выбора
    case venus,
    case earth,
    ...
}
let terra = Planets.earth; // (const) литералы перечисления - константы, область видимости которых - само перечисление
var p = Planets.venus; // переменная
p = .mars; // Planets можно убрать, если нет конфликтов перечислений (но . остается)
// Planets становится явно выводима из целочисленного тд
var pl:Planet =.venus;
switch pl {
    case .mars:  ...;
    case .venus: ...; // break не нужны
    ...
    default: {...}
}
// let t = expr; - не нужно выносить и загрязнять область видимости
switch let t=expr { // компактно ссылаемся на эту метку t (и показываем, что это константа)
    case ...
}
enum ControlChars:AsciiCharacters {
    case CR = '\r',
    case LF = '\n',
    case TAB = '\t',
    ...
}
```

``` {.swift}
enum Planets:CaseIterable { // протокол
    case mercury,
    case venus,
    case earth,
    ...
} // появится свойство  AllCases

for (p in Planets.AllCases) {
    print(p); // распечатать коллекцию всех имен
}
```

``` {.swift}
enum Planets:String { // элементы станут строковыми константами
    case mercury=1,
    case venus,
    case earth="earth",
    ...
}
```

``` {.swift}
enum BarCode {
    case BC(Int, Int, Int, Int), // можем ассоциировать набор значений
    case QR(String)
} // запись с вариантами
var B:BarCode = .BC; // ОШИБКА!!! Надо задать ассоциированные значения
var B:BarCode = .BC(5, 56538, 36211, 3);
switch B {
    case .BC (let NS, let MC, let PC, let Check) : { // значения типизируются как ассоциированные поля, локализованы внутри этого оператора
        print(NS); // идентификаторы из другой ветки нельзя использовать
        print(MC);
        print(PC);
        print(Check);
    }
    // или
    // case .BC let(NS, MC, PC, Check): {...}
    case .QR let(S):
        print(S);   
}
```

> Как компилятор будет хранить --- не твое собачье дело, программист, ты
> там программируй.

#### Рекурсивные перечисления

Внутри ссылается само на себя. *Swift:* Дерево арифметических выражений

``` {.swift}
enum ArExpr {
    case Add(ArExpr, ArExpr), 
    case Mult(ArExpr, ArExpr),
    case Val(Int) // здесь рекурсия кончается
}
let two:ArExpr = .Val(2), five:ArExpr = .Val(5), three:ArExpr =.Val(3);
let t1:ArExpr = .Add(three, five);
let t2:ArExpr = .Mult(two, t1);
...
// переключатель, функция evaluate(e:ArExpr)
{
    switch e {
        case .Val let(v): 
            return v;
        case .Mult let(l, r):
            return evaluate(l) * evaluate(r);
        case .Add let(l, r):
            return evaluate(l) + evaluate(r);
        // default не нужен
    }
}   
```

### Объединение типов

Тип данных и его роль

``` {.c}
void process(T *p); // совместить несколько  типов данных в одном Т
```

-   Необъектные ЯП: можно описать только с помощью неразмеченных
    объединений =\> диспетчеризация по полю типа.
-   Объектные ЯП: наследование (но в какой-то степени тоже как
    диспетчеризация, см. пример)

``` {.c++}
class BarCodeBase {
public:
    BarCodeType bcType; // поле типа
    BarCodeBase(BarCodeType b) : bcType(b) {}
};
class QRCode: public BarCodeBase {
public:
    string s;
    QRCode() : BarCodeBase(QRCODE_TYPE) {}
};
class BarCode : publc BarCodeBase {
public:
    int numberSystem,
        manufactureCode,
        productCode,
        check;
    BarCode(int ns, int mc, int pc, int c) 
        : 
        numberSystem(ns),
        manufactureCode(mc),
        productCode(pc),
        check(c),
        BarCodeBase(BARCODE_TYPE) 
    {}  
};
// диспетчеризация по полю типа, плохой стиль
void Process(BarCodeBase *pBC) {
    switch(pBC->bcType) {
    case QRCODE_TYPE: {
        QRCode *pQR = (QRCode *)pBC;
        cout << pQR->s;
        break;
    }
    case BARCODE_TYPE: {
        BarCode *pB = (BarCode *)pBC;
        cout << pB->numberSystem;
        ...
        break;
    }
    }
}
// можно статически привести в нужном case 
BarCode *pB = static_cast<BarCode *>(pBC);
// для полиморфных классов есть dynamic_cast, пусть есть virtual функция
void Process(BarCodeBase *pBC) {
    BarCode *pB = dynamic_cast<BarCode*>(pBC);
    if (pB) {
        cout << pB->numberSystem;
    } else {
        QRCode *pQR = dynamic_cast<QRCode*>(pBC);
        cout << pQR->s;
    }
}
// введем virtual print() в BarCodeBase (стремиться нужно к такому коду):
void Process(BarCodeBase *pBC) {
    pBC->print(); // тогда нужно заранее определить набор базовых действий и поместить его в базовый класс. Это невозможно, например, при использовании API OS
}
```

> Я нигде никаких дефолтов, извините за клоачный язык, не ставлю.
>
> *Немного дополнений:* Словари: Go, Swift, Python --- добавлены в базис
> языка.

``` {.swift}
let s:String = "A"; // immutable
var s1:String = "B"; // mutable
```

### Операторы

Изменение функцией своих параметров --- побочный эффект. Изменение
функцией глобальных переменных --- нежелательный побочны эффект. \>
"GOTO statement considered harmful"

Все арифметико-логические команды --- это выражения (expressions).

Операторы: \* перехода (команды управления последовательностью
вычислений) \* пересылки \* ввода/вывода

В Fortran раньше был единственный оператор управления:

``` {.fortran}
IF(e) M1, M2, M3 // три метки - <0, ==0, >0 (изначально для трехадресных машин)
```

И один оператор цикла с фиксированным числом повторений:

``` {.fortran}
DO 5 I=1,3
...
5 CONTINUE
```

Оператор перехода (их было много):

``` {.fortran}
GOTO 5
```

Основные операторы циклов: \* while B do S \* repeat s1; ...; sN until B
\* for i:= l1 to l2 do S

### Лекции 23, 24

### Операторы

-   :=
-   ветвления (if, case/switch)
-   циклы (while, repeat, for)
-   заменители goto (break, continue, return)

Цикл: \* Подготовка данных \* Проверка данных (отсюда может быть выход
из цикла) \* Обработка

``` {.c}
int ch;
while ((ch = getchar())!=EOF)
    processData();
// если бы присваивание не было операцией, то пришлось бы делать так:
int ch;
ch = getchar();
while (ch!=EOF) {
    processData();
    ch = getchar();
    // дублирование кода!!!
}
// проверка данных, так например в Паскале, перед чтением надо проверять готовность данных, иначе чтение не пройдет и все свалится
while (checkData()) {
    inputData();
    processData();
    // тут мы не уходим от проблемы дублирования кода
}
```

Fortran, PL-1: ON OVERFLOW \<operators\> ON ENDFILE \<operators\> ---
авария, попытка прочитать за концом файла, оператор выхода из цикла *C:*

``` {.c}
for(;;) { // бесконечный цикл
    prepareData();
    if (!ready) break;
    processData();
}
```

В Modula 2 оставили операторы из Паскаля и добавили бесконечный цикл:
`Modula 2 LOOP     // operators     IF B THEN EXIT // выход из цикла END`
*Swift:*

``` {.swift}
while B {
    // operators
}
repeat {
}
```

*Go:*

``` {.go}
// есть только цикл for
for init; cond; post {
    //
}
for i:=0; i <= N; i++ { // for
    //
}
for i <= N { // while
    //
}
for { // infinite
    //
}
```

> Программистам Microsoft платят за строки, поэтому пишем, как
> Маяковский, --- столбиком! { dosomething(); }

*Python:*

``` {.python}
while B:
    pass #
for i in range(0, N): # в смысле foreach
    pass #
for i in stdin.read():
    pass #
# в python есть if, но нет switch
# используется словарь, как и в С# встроенный в библиотеку
# значением словаря может быть лямбда
# для цикла for есть оператор else
for i in range(0, N):
    pass # если тут будет break, то else не выполнится
else:
    pass # тут может быть какая-то очистка ресурсов, например 
```

> Представьте себя маленьким симпатичным интерпретатором... Вот в 90-х у
> программистов шиза была --- представлять себя маленькой операционной
> системой.

*Modula 2:* `Modula 2 for i:=e1 to e2 [step3] do S` Появление
интерфейсов: набор методов, данных. В С++ --- полностью виртуальный
класс

``` {.c++}
class ISet {
public:
    virtual bool In(T x) = 0;
    ...
    virtual ~ISet() {} /* обязательно надо написать тело, он не может быть чисто виртуальным. 
    Конструктор может быть сгенерированным, но деструктор - нет, иначе он будет не виртуальным.*/
};
```

*C\#:*

``` {.c#}
interface IEnumerable { // все, что поддерживает интерфейс GetEnumerator, - коллекция
    bool MoveNext();
    Object Current; get;
    void Reset();
}

// foreach(T x in C) S // С - коллекция, :
Iterator it = C.GetEnumerator();
while (it.MoveNext()) {
    x = it.Current;
    ...
}
```

``` {.c#}
interface IDisposable {
    void Dispose(); // уничтожение элемента
}

Image im = Image.FromFile("C:\\i.jpg");
// мы точно не знаем, когда выполнится деструктор
/* здесь может возникнуть исключение, поэтому нам нужна гарантия удаления объекта: */
Image im = Image.FromFile("...");
try {
    processImage(im);
} finally {
    ((IDisposable)im).Dispose(); // гарантированное выполнение
}
// если аварийное завершение, то все равно будет вызван деструктор
im.Dispose(); // здесь явное удаление
```

``` {.c#}
using (Image im = Image.FromFile("...")) {
    processImage(im);
    // using блок превращается в try-finally, для im будет должным образом вызван Dispose, если im поддерживает этот интерфейс (иначе - ошибка)
}
```

try-finally присутствует во всех объектно-референциальных ЯП. *Java:*

``` {.java}
// foreach(T x in C) S
for (T x : C) S // C поддерживает коллекцию
```

``` {.c++}
int a[] = {1, 2, 3, 4, 5};
for (int x : a) {...}
for (auto x : a) {...}
for (auto &x : a) {//передача по ссылке, чтобы не копировать каждый раз, можно менять элементы}
for (const auto &x : a) {// передача по ссылке, менять нельзя}
```

*Go:*

``` {.go}
// если это коллекция, то к ней применимо ключевое слово range
for k, v := range C { // итератор по коллекции
    // k - ключ, v - значение
    // если массив, то k - индекс, v - значение
    // если строка, то k - позиция от начального байта, v - rune (значение в unicode)
    // если map (входит в базис), k - ключ, v - значение
}
// map[тип ключа] тип значения
d map[string] string
for _, v := range C { // фактически, foreach

}
```

*Swift:*

``` {.swift}
for x in C {

}
```

### Средства развития

-   Подпрограммы (абстракция алгоритма)
-   Новые типы данных
-   Модули

##### Средства защиты

-   Инкапсуляция
-   что-то еще

Темы: \* Передача данных в подпрограммах \* Передача управления
(сопрограммам и подпрограммам) \* Функциональные ТД

#### Передача данных

Динамическое связывание Фактическаие параметры и формальные

В языке Ada в функциях запрещена модификация параметров (переменные
только in, не inout, как было в языке Green). Процедуры могут менять
параметры, но не имеют возвращаемого значения. Не надо менять в функиях
глобальные переменные!

**InOut семантика** Способы передачи параметров (связывание параметров):
\* *In семантика* --- параметр не меняется \* *Out семантика* ---
выходной параметр, изначальное определение параметра не требуется \*
*InOut семантика* --- входной параметр изменяется В идеале --- просто
сформулировать InOut семантику, а выбор сособа передачи параметров
передать компилятору. *Ada:*

``` {.ada}
procedure P (X : in T, I : inout T, Z : out T);
```

Способы (значения фактических и формальных параметров хранятся в стеке):
1. По значению (in) Фактические параметры копируются в формальные 2. По
результату (out) Значения формальных параметров копируются в фактические
3. По значению/результату (inout) Фактические параметры копируются в
стек перед вызовом, а по возвращении формальные копируются в
фактические: вычисляются значения и места размещения фактических
параметров, значения присваивают формальным параметрам, после выполнения
тела подпрограммы конечные значения формальных параметров копируются
обратно в места размещения, вычисленные ранее. 4. По адресу/ссылке
Передаем либо адрес, либо процедуру вычисления адреса. Наиболее
универсальный, с его помощью можно реализовать все 3 семантики. В
Fortran изначально все параметры передавались так. 5. По имени (by name)

> В старых вариантах лекций, переписывая с аудио, кто-то писал "по
> значению результата"

В современных ЯП мы специфицируем способ передачи параметров (по ссылке,
по значению).

``` {.ada}
procedure P(X, Y : inout T) is
begin
    X := newval1;
    Y := newval2;

end;
// Проблемы возникают, когда передаем одно и то же значение:
P(A, A); // результат будет зависеть от реализации компилятора
P(A(i), A(j));
// что если внутри процедуры будет аварийная ситуация? второе значение может оказаться неопределенным
```

C: f(i++, ++i) --- нестандартизовано В С++ по умолчанию все передается
по значению, еси специфицируем --- то по ссылке.

*C\#:*

``` {.c#}
void f(Object o) {}
struct C {...}
...
C c = new C();
f(c); // неявно происходит упаковка и распаковка объекта
void f(T x) {} // если объект х - интерфейс, объект и тд, то по ссылке, иначе по значению
T a = new T();
```

Передача параметров по значению и по ссылке (ссылку тоже можно передать
по ссылке)

``` {.c#}
void f(ref int i) {
    ...
    i = 5;
    ...
}
int i;
f(ref i); // ошибка времени выполнения, ref - inout семантика, параметр должен быть определен!
f(out i); // задаем out семантику, i может быть неопределен
int a = 1;
f(ref a);
// Классы обертки:
int Int32.Parse(string s); // если там может быть не число, то:
bool Int32.TryParse(string s, out i); // не требуется изначального определения i, но i надо описать где-то
// чтобы избавиться от этого, внутри условного оператора можно объявить i = TryParse
```

``` {.c#}
void Init(out X a, out X b, out X c) {
    a = new X();
    b = new X();
    c = new X();
}
Init(out a, out b, out c);
```

**thunk** --- передача по имени some language:

    procedure P(X byname T)
        X := 0
    T a;
    P(a); 

В Algol68 нельзя написать корректно работающую программу swap

    procedure swap(x, y: byname int)
        t : int;
    begin
        t := x;
        x := y;
        y := t;
    end

    int a[10];
    int i = 0;
    swap(a[i], i); // thunk для i вычисляет адрес i, для a[i] - адрес, на основе i. будет работать некорректно

Перегрузка оператора присваивания

``` {.c++}
X &operator=(const X &rhs) {
    if (&rhs == this)
        return *this; // нельзя удалять старые данные, вдруг мы присваиваем самого себя
    // здесь можно удалять старое и делать глубокое присваивание rhs
}
```

В Lisp параметры как-то передаются, это не так важно (ничего не
меняется, никаких проблем не возникает из-за отсутствия понятия
состояния).

#### Передача управления

*Подпрограмма* Caller (глваная программа) -\> Call (вызов) -\> Callee
(вызываемый) -\> Return -\> .Call (возврат в точку вызова)-\>
продолжение программы *Сопрограмма* (похоже на два потока управления) P1
-\> Resume P2 -\> P2 -\> Resume P1 -\> .Resume P2 (возврат в точку) -\>
\<...\> -\> Resume P2 -\> P2 -\> Resume P1 -\> .Resume P2

### Лекции 25, 26

### Передача управления

**Сопрограмма** \* Для подпрограмм: Главная программа (caller) и
подпрограмма (callee). Главная программа сохраняет в стеке адрес
возврата (стековый фрейм). \* В сопрограммах: Нет главной программы, нет
ключевых слов call и return, есть resume. Но это не многопоточность,
хоть речь и идет о потоках управления. Round Robin. С точки зрения
реализации сопрограмма должна хранить свое состояние (адрес
возобновления, стек, регистры и тд). Modula 2:
`Modula 2 PROCEDURE NEWPROCESS     (P: PROC; N: CARDINAL; VAR C: ADDRESS); // COROUTINE; N - размер рабочей области PROCEDURE RESUME     (VAR C1: ADDRESS);// в С1 запоминается адрес памяти, в которой запомнено состояние сопрограммы С1, управление передается С2`

    // MODULE M[4];
    DEFINITION MODULE M[4];
        TYPE SIGNAL
        PROCEDURE WAIT(VAR S: SIGNAL);
        PROCEDURE SEND(VAR S: SIGNAL);
        PROCEDURE INIT(VAR S: SIGNAL);

    DEFINITION MODULE [4]; // типичный интерфейс
    IMPLEMENTATION MODULE [4]; // модули реализации, могли быть откомпилированы после модуля определения.

m.mod -\> m.obj m.def -\> m.sym

*C\#:*

``` {.c#}
Interface IEnumerable/*<T>*/ {
    IEnumerator/*<T>*/ GetEnumerator();
}
Interface IEnumerator {
    Object/* T*/ Current; get;
    bool MoveNext();
    void Reset();
}

// foreach (T x in C)
IEnumerator i = C.GetEnumerator();
while (i.MoveNext()) {
    x = (T)/**/i.Current;
    ...
}
```

``` {.c#}
class Iterator: IEnumerator<T> {
    T []arr;
    int index;
    Iterator(T []a) {
        arr = a;
        index = -1;
    }
    bool MoveNext() {
        index++;
        return index < arr.length;
    }
    void Reset() {
        index = -1;
    }
    T Current {
        get { return arr[index]; }
    }
}
class Collection: IEnumerable {
    T []arr = new T[3];
    public IEnumerator<T> GetEnumerator() {
        return new Iterator(arr);
    }
}
```

``` {.c#}
IEnumerator<T> GetEnumerator() {
    int index = 0;
    while (index < arr.length) {
        yield return arr[index];
        index++;
    }
    yield break;
}
```

*Python:*

``` {.python}
#python2
xrange(1, 1000) # генератор
range(1, 1000) # список
#python3
range(1, 100) # генератор
def fib(n):
    a = 1
    b = 1
    i = 1
    while i < n:
        yield a
        a, b = b, a+b
        i += 1

g = fib(100) # g - генератор
next(g) # прогон до следующего yield
...
# после 100 GeneratorExit exception
def gen(l):
    i = 0
    while len(l) > i:
        yield l[i]
        i += 1

def sum():
    count = 0
    while True:
        count += (yield) # yield-выражение
        print(count)
s = sum()
next(s)
s.send(5) # 5 в качестве yield-выражения, напечатано 5
s.send(8) # напечатается 13
```

### Передача параметров

1.  Переменный список параметров
    -   Параметры по умолчанию (но их все равно конечное число)

    ``` {.c++}
    int f(int x=0, int y=1);
    f();
    f(1);
    f(1, 2);
    ```

2.  Позиционный способ указания параметров

<!-- -->

    f(,,,val1, ,, val2)

3.  Ключевой способ указания параметров (указание имени)

<!-- -->

    f(value1: val1, value2: val2)
    func name_func(label:name:type, ...) -> type
    func sub(offset:ofs:int) -> int
    sub(offset:1)

*C\#:*

``` {.c#}
void foo(int a, params double[] d);
void foo(int a, double[] d); // разные функции!
foo(0, 1.0, 2.0, 3.0); // соберется в массив и передастся в первую функцию
foo(0, new double[]{1.0, 2.0, 3.0}); // явное задание массива double
void foo(params Object[] o); // переменный список параметов любого типа
// Java: void foo(Object... o)
```

*Swift:*

``` {.swift}
func foo(_ a: Int, _ d: Double...) {
    print(a, d) // 1 [2.0, 3.0, 4.0]
}

foo(1, 2, 3, 4)
```

*Java и C\#:*

``` {.java}
Object o = Integer(5); // автораспаковка
Int32 i = (Int32)o;
int ii = i;
Object o1 = 5; // автоупаковка
```

### Функциональные типы данных

``` {.c}
typedef void (*pvf)(); // pvf() - тогда должен быть указатель
// void (*pvf())() - функция, возвращающая указатель на функцию типа void
void bar();
pvf foo = bar; // *foo = bar
```

*Ada:*

``` {.ada}
TYPE PPC = PROCEDURE(VAR: INTEGER, REAL):REAL;
```

Замыкание

``` {.pascal}
procedure P(i:integer);
    var j, k: integer;
    procedure InnerP(l:integer);
        begin:
            ..k, j, l..
        end;
    begin:
        InnerP;
    end;
```

*Python:*

``` {.python}
def inc1(): # замыкание
    n = 0
    def f():
        n += 1
        return n
    return f

def incNbyM(N, M): # замыкание
    n = N
    def f():
        n += M
        return n
    return f

def add(x, y):
    return x+y

def add1(x): # не замыкание
    return add(x, 1)

def add1_1(): # замыкание
    def adder1(x):
        return add(x, 1)
    return adder1

def add1_2():
    return LAMBDA(x): add(x, 1)

inc1 = add1_1()
inc1(5)
```

*JavaScript:*

``` {.javascript}
function add(x, y) {return x+ y}
function add1()
{
    return x => add(x, 1) // или вот так:
    // function(x) {return add(x, 1)} // анонимная функция
}
```

*С++:*

``` {.c++}
class X {
public:
    static void f(x);
    void g() {..}
    int j;
};
typedef void (*pvf)();
pvf foo;
foo = X::f;
foo = X::g; // ошибка, g - функция-член, для нее отдельный вид указателя
int X::*p; // указатель на член класса X типа int (должен быть static), чтобы можно было обратиться не через экземпляр класса:
/* int X::*pp = &X::j; static int j in class X, указатель не совсем указатель, а скорее смещение от начала полей класса*/
X a;
p = &X::j;
a.*p; // обращение к члену j
X *pa;
pa->*p;
```

### Лекции 27, 28

### Функциональные типы данных

*C++, C\#, Java:* \* Глобальные функции (статические функции-члены) \*
Функции-члены (нестатические)

*C++:*

``` {.c++}
int x;
class A {
public:
    static int g;
    int i;
    int k;
    void foo();
    static void bar();
    void q();
};
...
int *pi;
pi = &x;
pi = &A::g; // указатель на статический член - просто как указатель на такую переменную
int A::g = 1;
*pi = 2;
int A::*piA;
piA = &A::i;
piA = &A::k;
A a;
// &a.i - можно
// a.*piA
piA = &A::i;
pi = &a.i;
// a.*piA ~ *pi
pvf = &A::bar;
void (A::*pf)();
pf = &A::foo;
pf = &A::q;
a.*pf();
// информацию о том, виртуальная ли функция, надо хранить с указателем
```

``` {.c++}
// find_if(it1, it2, f) - ?
class Functor {
    T _a;
public:
    bool operator()(T x) {return x == _a;}
    Functor(a) {_a = a;}
};
int arr[N];
int k;
find_if(begin(arr), end(arr), Functor(k));
// it =?= end(arr)
```

``` {.c++}
#include <functional>
// std::function<R(a1, a2, ..)>
std::function<void()> func;
func = &A::bar();
func = &A::foo();

class VoidFunc {
public:
    void operator()(){..}
};
VoidFunc f;
func = &f;
func(); // вызов
```

``` {.c++}
int add(int a, int b) {return a + b;}
inr sub(int a, int b) {return a - b;}
std::function<int(int, int)> f;
f = add;
std::function<int(int)> f1 = std::bind(f, 2, 10); // add
auto foo = std::bind(add, _1, 5); // std::function<int(int)> 
foo(5);
auto bar = std::bind(sub, _1, 8);
bar(25); // первый аргумент sub, а вторым будет 8, результат 17
bar = std::bind(sub, _2, 8);
bar(25); // -17 (25 вместо второго аргумента)
```

``` {.c++}
int b = 25;
auto f = []; // lambda - анонимный функтор
auto f = [&b](int a) {return b += a;};
f(1);// 26
f(2);// 27
...
class ...{
    auto f1 = [this](int a) {int k...}
    // глобальные переменные не входят в замыкание
    // неявные ссылки на глобальные переменные запрещены
};
```

``` {.c++}
int arr[10];
int k;
find_if(begin(arr), end(arr), [k](int x) {return x == k;});
```

*C\#:*

``` {.c#}
type fii = function(i, j : integer) : integer;
```

*C\#:*

``` {.c#}
// все есть класс
//System Delegate
//  MulticastDelegate
pvf cb;
class X {
    delegate void pvf();
    void foo() {..}
    static void bar() {..}
}
class Y {
    public void g() {..}
    public static void gg() {..}
}
void xxx() {
    cb = new pvf(foo);
    Y y;
    cb += new pvf(bar);
    cb += new pvf(Y.gg);
    cb += new pvf(Y.g);
    cb(); // все зарегистрированные делегаты будут вызваны
    
```

Делегаты не являются отдельным типом данных. Зато используется для
оповещения о событиях (подписка: +=, отписка: -=, рассылка - вызов).

``` {.c#}
public event pvf myEv; // на этот экзамепляр: изнутри применимы все операции, извне (из другого класса) только += и -=.
myEv = new pvf(X.foo)
myEv();

public event pvf cb {
    add{..}
    remove{..}
    // можно добавить свою семантику в терминах += и -=
    // () нельзя переопределять
}
```

**Обобщения** *C\#:*

``` {.c#}
class X<..>
delegate TR Func<T, TR> (T x);
// уже никто не пишет delegate
void MyMethod(Func<int,int, int> f) {
    int i = f(0, 1);
    ...
}
EventHandler<T> // T -> EventArgs
static int add(int x, int y) {return x+y;}
Func<int, int, int> f = add;
Action<T1, T2, ..., TN>
Func<int, int> adder(int n) { return add(1, n); } // будет сообщение об ошибке, так как возвращается выражение типа int, а надо возвращать функцию от одного параметра
Func<int, int> adder(int n) {
    Func<int, int> res = int delegate(int k) { return add(k, n); }
    return res;
}
var add5 = adder(5);
int i = add5(18);
```

``` {.c#}
//лямбда выражение (не делегат, а в некотором смысле генератор экземпляров делегатского типа. непонятно, какой тип возвращается
x => x+1; // список аргументов => выражение
(x, y) => x + y
(x, y) => {return x + y;} // можно писать в блоках

Func<int, int, double> f = (x, y)=>x+y;
void M(Func<int, int> adder);
M(x=>x+1);
```

*C++:*

``` {.c++}
class Outer {
public:
    class Inner{..}
    static int i;
};
Outer::Inner in;
Outer::i = -1;
// а в Java и С# понятие статического класса появляется
```

*Java:*

``` {.java}
import <имя_пакета>.* // внутри класс или интерфейс
System.IO.Path
static class Path
```

``` {.java}
class WI {
    string s = "Hello";
    public Button MakeButton() {
        Button res = new Button{
            @override
            protected void OnClick() {
                caption = s;
            }
        }();
        return res;
    }
}

interface ISomething {
    void foo;
    int bar(int);
    int count;
    int key; set;
    // данных у интерфейса не может быть, это только функции
    // для события надо указать методы add и remove
    event pvf cb; add; remove;
}
```

### Лекция 29, 30

### Функции в Java

-   1995 -- 2014: не было функций, были методы (невозможны без класса).
-   1999: в Java2 понятия внутреннего и анонимного класса (их методы уже
    были замыканиями). В методы внутреннего класса могли входить ссылки
    на внешние переменные.

``` {.java}
class Bar {
    int _mem;
    void foo(int i) {
        int k;
        Button b = new Button {
            void OnClick() {//тут могут быть ссылки на i, k и _mem}
            // каждый объект внутреннего класса имеет ссылку на внешний класс
        }
    }
};
```

-   2005: обобщения (классы и интерфейсы)

``` {.java}
interface ISomething {
    void foo();
    int bar(int i);
}
class CoClass implements ISomething {
    public void foo() {..}
    public int bar(int i) {..}
}

CoClass c = new CoClass();
ISomething f = c; // интерфейсы наследуемы множественным образом, так как наследуется таблица виртуальных методов
f.foo();
```

-   функциональный интерфейс --- интерфейс, в котором есть только одна
    функция

``` {.java}
@FunctionalInterface // необязательно, но если добавить, то компилятор будет ругаться при попытке добавить второй метод в такой интерфейс
interface IFoo {
    int bar(int i);
}
// @override - функция переопределяется (должна замещать, полностью совпадать по прототипу)
IFoo i = (int x)->{return x+1;};
System.out.println(i.bar(5)); // вывод - 6
```

``` {.java}
interface Function<T, R> {
    R apply(T x);
}
interface BiFunction<T1, T2, R> {
    R apply(T1 x, T2 y);
}

interface UnaryOperator<T> {
    T apply(T x);
}
interface BinaryOperator<T> {
    T apply(Tx, Ty);
}
// в Java интерфейсы не перегружаются!
interface Predicate<T> {
    bool test(T x);
}

interface Consumer<T> {
    void accept(T x);
}
interface Supplier<T> {
    T get();
}

interface Compare<T> {
    bool compare(T x, Ty);
}
```

-   default-methods

``` {.java}
interface Function<T, R> {
    R apply(T x);
    default
    T compose(T x);
    default
    T andThen(R x);
}
Function<T, R> f = (T x)->{return r;// r типа R};
Function<Integer, String> f1 = new Function<Integer, String>() {
    String apply(Integer i) {
        String.valueOf(i);
    }
}; // хоть и интерфейс, но тут будет анонимный внутренний класс
// можно записать и в виде лямбды, будет короче
Function<Integer, String> f2 = (Integer i)->{return String.valueOf(i);};
// можно и методы
Function<Integer, String> f3 = String::valueOf;
f3.apply(2);
```

#### Java. Ссылки на методы

``` {.java}
// статические
Function<T, R> f1 = Class::method; // method должен удовлетворять сигнатуре f.apply (Function - произвольный интерфейс)
// нестатический
//Class:method
BiFunction<Class, T, R> f2 = Class::method;
Class c;
R r = f2.apply(c, t);
// ссылка первого рода (самим надо передавать this)
Function<T, R> f3 = c::method; // c - объект класса, даст ссылку на this, метод нестатический
R r = f3.apply(t);
// ссылка на конструктор
Class::new; // может удовлетворять практически любому интерфейсу. если конструктор умолчания, то удовлетворяет Supplier
```

``` {.java}
/* ? f = ?? */
Locale lRu = f.apply("ru", "RU");
Locale lEn = f.apply("en", "UK");
// варианты f
// 1
BiFunction<String, String, Locale> f = new BiFunction<String, String, Locale>() {
    Locale apply(String lang, String country) {
        return new Locale(lang, country);
    }
}; // обертка вокруг конструктора
// 2
BiFunction<String, String, Locale> f = (lang, country)->new Locale(lang, country);
// 3
BiFunction<String, String, Locale> f = Locale::new;
```

#### Потоки в Java

``` {.java}
// Stream API
List<int> l = new List<int>();
l.stream().max((i, j)-> i > j);// max - терминальный метод, как и min(), sum()
// еще у потоков есть методы average(), count() и другие
// sum и average - варианты метода reduce
l.stream().filter(x->x>0).sorted().map(System::println); // filter оставит только числа >0, sorted - терминальный метод, сортировка, map распечатает с помощью println
// иначе нужно было бы делать
for (int x: l) {/*filter*/} // получится какая-то последовательность l1
for (int x: l1) {/*sort*/}
for (int x: l1) {/*print*/}

// тип данных optional
Optional<T> // либо пусто, либо какое-то значение
Optional<Integer>
// вместо Stream можно сделать parallelStream, тогда операции будут применяться параллельно
//.reduce(initVal, BinaryOperator<T> f)
l.stream().reduce(0, (x, y)-> x + y); // так можно записать sum через reduce
```

### Go

``` {.go}
// go-рутины
go func(...) /*тип*/ {...} (/*вызов с аргументами*/);
c := make(chan int, 0)
c<-0 // ввод в канал
<-c // чтение из канала
```

``` {.go}
// числа Фибоначчи через каналы
package main
import {"fmt"}
func fib(n int, c chan int) /*нет типа*/ {
    x, y := 0, 1 
    for i := 0; i < n; i++ {
        c<-x // вывод в канал, зависает, пока кто-то не считает (похоже на yield в python, сопрограмма)
        fmt.Println("number ")
        x, y = y, x+y
        
    }
    close(c)
}
//fib будет работать как сопрограмма за счет нулевой емкости канала
func main() {
    c := make(chan int, 0) // 0 по умолчанию, канал нулевой емкости
    go fib(10, c)
    // выполнение идет дальше асинхронно
    for i := 0; i < 10; i++ {
        x := <-c // будет ждать ввода
        fmt.Println(x)
    }
}
```

``` {.go}
import {"fmt", "time"}
func main() {
    tick := time.Tick(100 * time.Millisecond)
    boom := time.After(500 * time.Millisecond)
    for {
        select {
          case <-tick:
            fmt.Println("tick")
          case <-boom:
            fmt.Println("boom")
            return
          default:
            // есть дефолт, тогда не будет зависать, если ни в один канал ничего не вывели
            fmt.Println("...")
            time.Sleep(50 * time.Millisecond)
        }
    }
}
```

### Введение в обобщенное программирование

generics C++, C\#, Java поддерживают Go не поддерживает

**Обобщенное программирование:** Статическая параметризация типов (как
правило во время трансляции) С++ самый мощный с точки зрния generics.

1.  Надежность Гарантируется, что у контейнера только один тип данных
2.  Эффективность Введение обобщенных коллекций в C\# (не надо
    поддерживать гомоморфность коллекций), у Java такой эффективности
    нет

#### C++

-   Определение шаблона (класса, функции)
    -   Формальные параметры
-   Конкретизация шаблона
    -   Фактические параметры
-   Специализация шаблона
    -   Частичная (все равно приводит к какому-то шаблону, более
        специализированному)
    -   Полная

STL контейнер -\> итератор \<- алгоритм

``` {.c++}
template<class T, int size, void (*pfn)()> class X {
    T::iterator; // компилятор ничего не может сказать о Т, кроме того, что это класс
    // iterator - имя либо статического члена (тогда все ок), может фигурировать имя класса. компилятор считает, что более частая ситуация - статический член, поэтому надо:
    typename T::iterator;
    function<void()>
};
```

``` {.c++}
std::basic_string<char> // через typedef определена как string
// конкретизация для функций определялась как перегрузка
// нельзя было написать шаблон (так как в шаблон входит возвращаемое значение)
template<typename T>
T get() {..}
exp(1.0);
exp(1.0f);
// сейчас можно явным образом указать и задать шаблон
get<x>();
exp<double(1);
```

``` {.c++}
// специализация
// полная (1):
template<class T>
class X {..};
// частичная (2):
template<class T>
class X<T*> {..};
// у функций нет частичной чпециализации (этого можно достигнуть через специализацию параметров)
X<int> x; // (1)
X<int*> x1; // (2)
X<const char*> x2; // (2)
// (1)
template<class X, class Y>
class T{..};
// (2)
template<class X>
class T<X, int> {..};// не имеет отношения к классу Т (1) выше, интерфейсы могут быть разные
//template<>
class T<int, int> {..}; // (3)
T<int, double>; // полная (1)
T<double, int>; // частичная (2)
T<int, int>; // полная (3)
```

SFINAE --- substitution failure is not an error

``` {.c++}
template<int N> 
struct Fact {
    enum { res = Fact<N-1>::res*N; };
};
template<>
struct Fact<0> {
    enum { res = 1; };
};
int main() {
    cout << Fact<10>::res; // выдаст факториал 10
}
```

``` {.c++}
template<int A[], int N>
struct Sum {
    enum { res = A[N-1] + sum<A, N-1>; };
};
// для 0 тоже надо
int a[] = {1, 3, -6, 17, ..};
constexpr
    //...
```
